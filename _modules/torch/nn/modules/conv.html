

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>torch.nn.modules.conv &mdash; dpipe  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../../search.html"/>
    <link rel="top" title="dpipe  documentation" href="../../../../index.html"/>
        <link rel="up" title="Module code" href="../../../index.html"/> 

  
  <script src="../../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../index.html" class="icon icon-home"> dpipe
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../dpipe.html">dpipe package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">dpipe</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>torch.nn.modules.conv</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for torch.nn.modules.conv</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding=utf-8</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">torch.nn.parameter</span> <span class="k">import</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">functional</span> <span class="k">as</span> <span class="n">F</span>
<span class="kn">from</span> <span class="nn">.module</span> <span class="k">import</span> <span class="n">Module</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="n">_single</span><span class="p">,</span> <span class="n">_pair</span><span class="p">,</span> <span class="n">_triple</span>


<span class="k">class</span> <span class="nc">_ConvNd</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span>
                 <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">transposed</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">bias</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_ConvNd</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">in_channels</span> <span class="o">%</span> <span class="n">groups</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;in_channels must be divisible by groups&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out_channels</span> <span class="o">%</span> <span class="n">groups</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;out_channels must be divisible by groups&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_channels</span> <span class="o">=</span> <span class="n">in_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_channels</span> <span class="o">=</span> <span class="n">out_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel_size</span> <span class="o">=</span> <span class="n">kernel_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stride</span> <span class="o">=</span> <span class="n">stride</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding</span> <span class="o">=</span> <span class="n">padding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dilation</span> <span class="o">=</span> <span class="n">dilation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transposed</span> <span class="o">=</span> <span class="n">transposed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_padding</span> <span class="o">=</span> <span class="n">output_padding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">groups</span> <span class="o">=</span> <span class="n">groups</span>
        <span class="k">if</span> <span class="n">transposed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span>
                <span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span> <span class="o">//</span> <span class="n">groups</span><span class="p">,</span> <span class="o">*</span><span class="n">kernel_size</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span>
                <span class="n">out_channels</span><span class="p">,</span> <span class="n">in_channels</span> <span class="o">//</span> <span class="n">groups</span><span class="p">,</span> <span class="o">*</span><span class="n">kernel_size</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">bias</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">out_channels</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register_parameter</span><span class="p">(</span><span class="s1">&#39;bias&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_parameters</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_channels</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_size</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">*=</span> <span class="n">k</span>
        <span class="n">stdv</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">uniform_</span><span class="p">(</span><span class="o">-</span><span class="n">stdv</span><span class="p">,</span> <span class="n">stdv</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">uniform_</span><span class="p">(</span><span class="o">-</span><span class="n">stdv</span><span class="p">,</span> <span class="n">stdv</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{name}</span><span class="s1">(</span><span class="si">{in_channels}</span><span class="s1">, </span><span class="si">{out_channels}</span><span class="s1">, kernel_size=</span><span class="si">{kernel_size}</span><span class="s1">&#39;</span>
             <span class="s1">&#39;, stride=</span><span class="si">{stride}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, padding=</span><span class="si">{padding}</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dilation</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dilation</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, dilation=</span><span class="si">{dilation}</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_padding</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_padding</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, output_padding=</span><span class="si">{output_padding}</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, groups=</span><span class="si">{groups}</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, bias=False&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;)&#39;</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Conv1d</span><span class="p">(</span><span class="n">_ConvNd</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Applies a 1D convolution over an input signal composed of several input</span>
<span class="sd">    planes.</span>

<span class="sd">    In the simplest case, the output value of the layer with input size</span>
<span class="sd">    :math:`(N, C_{in}, L)` and output :math:`(N, C_{out}, L_{out})` can be</span>
<span class="sd">    precisely described as:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \begin{array}{ll}</span>
<span class="sd">        out(N_i, C_{out_j})  = bias(C_{out_j})</span>
<span class="sd">                       + \sum_{{k}=0}^{C_{in}-1} weight(C_{out_j}, k)  \star input(N_i, k)</span>
<span class="sd">        \end{array}</span>

<span class="sd">    where :math:`\star` is the valid `cross-correlation`_ operator</span>

<span class="sd">    | :attr:`stride` controls the stride for the cross-correlation.</span>
<span class="sd">    | If :attr:`padding` is non-zero, then the input is implicitly zero-padded</span>
<span class="sd">      on both sides for :attr:`padding` number of points.</span>
<span class="sd">    | :attr:`dilation` controls the spacing between the kernel points; also</span>
<span class="sd">      known as the à trous algorithm. It is harder to describe, but this `link`_</span>
<span class="sd">      has a nice visualization of what :attr:`dilation` does.</span>
<span class="sd">    | :attr:`groups` controls the connections between inputs and outputs.</span>
<span class="sd">      `in_channels` and `out_channels` must both be divisible by `groups`.</span>
<span class="sd">    |       At groups=1, all inputs are convolved to all outputs.</span>
<span class="sd">    |       At groups=2, the operation becomes equivalent to having two conv</span>
<span class="sd">                 layers side by side, each seeing half the input channels,</span>
<span class="sd">                 and producing half the output channels, and both subsequently</span>
<span class="sd">                 concatenated.</span>
<span class="sd">            At groups=`in_channels`, each input channel is convolved with its</span>
<span class="sd">                 own set of filters (of size `out_channels // in_channels`).</span>

<span class="sd">    .. note::</span>

<span class="sd">         Depending of the size of your kernel, several (of the last)</span>
<span class="sd">         columns of the input might be lost, because it is a valid</span>
<span class="sd">         `cross-correlation`_, and not a full `cross-correlation`_.</span>
<span class="sd">         It is up to the user to add proper padding.</span>

<span class="sd">    Args:</span>
<span class="sd">        in_channels (int): Number of channels in the input image</span>
<span class="sd">        out_channels (int): Number of channels produced by the convolution</span>
<span class="sd">        kernel_size (int or tuple): Size of the convolving kernel</span>
<span class="sd">        stride (int or tuple, optional): Stride of the convolution</span>
<span class="sd">        padding (int or tuple, optional): Zero-padding added to both sides of</span>
<span class="sd">            the input dilation (int or tuple, optional): Spacing between kernel</span>
<span class="sd">            elements</span>
<span class="sd">        groups (int, optional): Number of blocked connections from input</span>
<span class="sd">            channels to output channels</span>
<span class="sd">        bias (bool, optional): If True, adds a learnable bias to the output</span>

<span class="sd">    Shape:</span>
<span class="sd">        - Input: :math:`(N, C_{in}, L_{in})`</span>
<span class="sd">        - Output: :math:`(N, C_{out}, L_{out})` where</span>
<span class="sd">          :math:`L_{out} = floor((L_{in}  + 2 * padding - dilation * (kernel\_size - 1) - 1) / stride + 1)`</span>

<span class="sd">    Attributes:</span>
<span class="sd">        weight (Tensor): the learnable weights of the module of shape</span>
<span class="sd">            (out_channels, in_channels, kernel_size)</span>
<span class="sd">        bias (Tensor):   the learnable bias of the module of shape</span>
<span class="sd">            (out_channels)</span>

<span class="sd">    Examples::</span>

<span class="sd">        &gt;&gt;&gt; m = nn.Conv1d(16, 33, 3, stride=2)</span>
<span class="sd">        &gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16, 50))</span>
<span class="sd">        &gt;&gt;&gt; output = m(input)</span>

<span class="sd">    .. _cross-correlation:</span>
<span class="sd">        https://en.wikipedia.org/wiki/Cross-correlation</span>

<span class="sd">    .. _link:</span>
<span class="sd">        https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">kernel_size</span> <span class="o">=</span> <span class="n">_single</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">)</span>
        <span class="n">stride</span> <span class="o">=</span> <span class="n">_single</span><span class="p">(</span><span class="n">stride</span><span class="p">)</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="n">_single</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
        <span class="n">dilation</span> <span class="o">=</span> <span class="n">_single</span><span class="p">(</span><span class="n">dilation</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Conv1d</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span> <span class="n">_single</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">groups</span><span class="p">,</span> <span class="n">bias</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">conv1d</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dilation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Conv2d</span><span class="p">(</span><span class="n">_ConvNd</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Applies a 2D convolution over an input signal composed of several input</span>
<span class="sd">    planes.</span>

<span class="sd">    In the simplest case, the output value of the layer with input size</span>
<span class="sd">    :math:`(N, C_{in}, H, W)` and output :math:`(N, C_{out}, H_{out}, W_{out})`</span>
<span class="sd">    can be precisely described as:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \begin{array}{ll}</span>
<span class="sd">        out(N_i, C_{out_j})  = bias(C_{out_j})</span>
<span class="sd">                       + \sum_{{k}=0}^{C_{in}-1} weight(C_{out_j}, k)  \star input(N_i, k)</span>
<span class="sd">        \end{array}</span>

<span class="sd">    where :math:`\star` is the valid 2D `cross-correlation`_ operator</span>

<span class="sd">    | :attr:`stride` controls the stride for the cross-correlation.</span>
<span class="sd">    | If :attr:`padding` is non-zero, then the input is implicitly zero-padded</span>
<span class="sd">      on both sides for :attr:`padding` number of points.</span>
<span class="sd">    | :attr:`dilation` controls the spacing between the kernel points; also</span>
<span class="sd">      known as the à trous algorithm. It is harder to describe, but this `link`_</span>
<span class="sd">      has a nice visualization of what :attr:`dilation` does.</span>
<span class="sd">    | :attr:`groups` controls the connections between inputs and outputs.</span>
<span class="sd">      `in_channels` and `out_channels` must both be divisible by `groups`.</span>
<span class="sd">    |       At groups=1, all inputs are convolved to all outputs.</span>
<span class="sd">    |       At groups=2, the operation becomes equivalent to having two conv</span>
<span class="sd">                 layers side by side, each seeing half the input channels,</span>
<span class="sd">                 and producing half the output channels, and both subsequently</span>
<span class="sd">                 concatenated.</span>
<span class="sd">            At groups=`in_channels`, each input channel is convolved with its</span>
<span class="sd">                 own set of filters (of size `out_channels // in_channels`).</span>

<span class="sd">    The parameters :attr:`kernel_size`, :attr:`stride`, :attr:`padding`, :attr:`dilation` can either be:</span>

<span class="sd">        - a single ``int`` -- in which case the same value is used for the height and width dimension</span>
<span class="sd">        - a ``tuple`` of two ints -- in which case, the first `int` is used for the height dimension,</span>
<span class="sd">          and the second `int` for the width dimension</span>

<span class="sd">    .. note::</span>

<span class="sd">         Depending of the size of your kernel, several (of the last)</span>
<span class="sd">         columns of the input might be lost, because it is a valid `cross-correlation`_,</span>
<span class="sd">         and not a full `cross-correlation`_.</span>
<span class="sd">         It is up to the user to add proper padding.</span>

<span class="sd">    Args:</span>
<span class="sd">        in_channels (int): Number of channels in the input image</span>
<span class="sd">        out_channels (int): Number of channels produced by the convolution</span>
<span class="sd">        kernel_size (int or tuple): Size of the convolving kernel</span>
<span class="sd">        stride (int or tuple, optional): Stride of the convolution</span>
<span class="sd">        padding (int or tuple, optional): Zero-padding added to both sides of the input</span>
<span class="sd">        dilation (int or tuple, optional): Spacing between kernel elements</span>
<span class="sd">        groups (int, optional): Number of blocked connections from input channels to output channels</span>
<span class="sd">        bias (bool, optional): If True, adds a learnable bias to the output</span>

<span class="sd">    Shape:</span>
<span class="sd">        - Input: :math:`(N, C_{in}, H_{in}, W_{in})`</span>
<span class="sd">        - Output: :math:`(N, C_{out}, H_{out}, W_{out})` where</span>
<span class="sd">          :math:`H_{out} = floor((H_{in}  + 2 * padding[0] - dilation[0] * (kernel\_size[0] - 1) - 1) / stride[0] + 1)`</span>
<span class="sd">          :math:`W_{out} = floor((W_{in}  + 2 * padding[1] - dilation[1] * (kernel\_size[1] - 1) - 1) / stride[1] + 1)`</span>

<span class="sd">    Attributes:</span>
<span class="sd">        weight (Tensor): the learnable weights of the module of shape</span>
<span class="sd">                         (out_channels, in_channels, kernel_size[0], kernel_size[1])</span>
<span class="sd">        bias (Tensor):   the learnable bias of the module of shape (out_channels)</span>

<span class="sd">    Examples::</span>

<span class="sd">        &gt;&gt;&gt; # With square kernels and equal stride</span>
<span class="sd">        &gt;&gt;&gt; m = nn.Conv2d(16, 33, 3, stride=2)</span>
<span class="sd">        &gt;&gt;&gt; # non-square kernels and unequal stride and with padding</span>
<span class="sd">        &gt;&gt;&gt; m = nn.Conv2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2))</span>
<span class="sd">        &gt;&gt;&gt; # non-square kernels and unequal stride and with padding and dilation</span>
<span class="sd">        &gt;&gt;&gt; m = nn.Conv2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2), dilation=(3, 1))</span>
<span class="sd">        &gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16, 50, 100))</span>
<span class="sd">        &gt;&gt;&gt; output = m(input)</span>

<span class="sd">    .. _cross-correlation:</span>
<span class="sd">        https://en.wikipedia.org/wiki/Cross-correlation</span>

<span class="sd">    .. _link:</span>
<span class="sd">        https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">kernel_size</span> <span class="o">=</span> <span class="n">_pair</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">)</span>
        <span class="n">stride</span> <span class="o">=</span> <span class="n">_pair</span><span class="p">(</span><span class="n">stride</span><span class="p">)</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="n">_pair</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
        <span class="n">dilation</span> <span class="o">=</span> <span class="n">_pair</span><span class="p">(</span><span class="n">dilation</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Conv2d</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span> <span class="n">_pair</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">groups</span><span class="p">,</span> <span class="n">bias</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">conv2d</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dilation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Conv3d</span><span class="p">(</span><span class="n">_ConvNd</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Applies a 3D convolution over an input signal composed of several input</span>
<span class="sd">    planes.</span>

<span class="sd">    In the simplest case, the output value of the layer with input size :math:`(N, C_{in}, D, H, W)`</span>
<span class="sd">    and output :math:`(N, C_{out}, D_{out}, H_{out}, W_{out})` can be precisely described as:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \begin{array}{ll}</span>
<span class="sd">        out(N_i, C_{out_j})  = bias(C_{out_j})</span>
<span class="sd">                       + \sum_{{k}=0}^{C_{in}-1} weight(C_{out_j}, k)  \star input(N_i, k)</span>
<span class="sd">        \end{array}</span>

<span class="sd">    where :math:`\star` is the valid 3D `cross-correlation`_ operator</span>

<span class="sd">    | :attr:`stride` controls the stride for the cross-correlation.</span>
<span class="sd">    | If :attr:`padding` is non-zero, then the input is implicitly zero-padded on both sides</span>
<span class="sd">      for :attr:`padding` number of points.</span>
<span class="sd">    | :attr:`dilation` controls the spacing between the kernel points; also known as the à trous algorithm.</span>
<span class="sd">      It is harder to describe, but this `link`_ has a nice visualization of what :attr:`dilation` does.</span>
<span class="sd">    | :attr:`groups` controls the connections between inputs and outputs. `in_channels` and `out_channels`</span>
<span class="sd">      must both be divisible by `groups`.</span>
<span class="sd">    |       At groups=1, all inputs are convolved to all outputs.</span>
<span class="sd">    |       At groups=2, the operation becomes equivalent to having two conv layers</span>
<span class="sd">                 side by side, each seeing half the input channels,</span>
<span class="sd">                 and producing half the output channels, and both subsequently concatenated.</span>
<span class="sd">            At groups=`in_channels`, each input channel is convolved with its own set of filters</span>
<span class="sd">                 (of size `out_channels // in_channels`).</span>

<span class="sd">    The parameters :attr:`kernel_size`, :attr:`stride`, :attr:`padding`, :attr:`dilation` can either be:</span>

<span class="sd">        - a single ``int`` -- in which case the same value is used for the depth, height and width dimension</span>
<span class="sd">        - a ``tuple`` of three ints -- in which case, the first `int` is used for the depth dimension,</span>
<span class="sd">          the second `int` for the height dimension and the third `int` for the width dimension</span>

<span class="sd">    .. note::</span>

<span class="sd">         Depending of the size of your kernel, several (of the last)</span>
<span class="sd">         columns of the input might be lost, because it is a valid `cross-correlation`_,</span>
<span class="sd">         and not a full `cross-correlation`_.</span>
<span class="sd">         It is up to the user to add proper padding.</span>

<span class="sd">    Args:</span>
<span class="sd">        in_channels (int): Number of channels in the input image</span>
<span class="sd">        out_channels (int): Number of channels produced by the convolution</span>
<span class="sd">        kernel_size (int or tuple): Size of the convolving kernel</span>
<span class="sd">        stride (int or tuple, optional): Stride of the convolution</span>
<span class="sd">        padding (int or tuple, optional): Zero-padding added to both sides of the input</span>
<span class="sd">        dilation (int or tuple, optional): Spacing between kernel elements</span>
<span class="sd">        groups (int, optional): Number of blocked connections from input channels to output channels</span>
<span class="sd">        bias (bool, optional): If True, adds a learnable bias to the output</span>

<span class="sd">    Shape:</span>
<span class="sd">        - Input: :math:`(N, C_{in}, D_{in}, H_{in}, W_{in})`</span>
<span class="sd">        - Output: :math:`(N, C_{out}, D_{out}, H_{out}, W_{out})` where</span>
<span class="sd">          :math:`D_{out} = floor((D_{in}  + 2 * padding[0] - dilation[0] * (kernel\_size[0] - 1) - 1) / stride[0] + 1)`</span>
<span class="sd">          :math:`H_{out} = floor((H_{in}  + 2 * padding[1] - dilation[1] * (kernel\_size[1] - 1) - 1) / stride[1] + 1)`</span>
<span class="sd">          :math:`W_{out} = floor((W_{in}  + 2 * padding[2] - dilation[2] * (kernel\_size[2] - 1) - 1) / stride[2] + 1)`</span>

<span class="sd">    Attributes:</span>
<span class="sd">        weight (Tensor): the learnable weights of the module of shape</span>
<span class="sd">                         (out_channels, in_channels, kernel_size[0], kernel_size[1], kernel_size[2])</span>
<span class="sd">        bias (Tensor):   the learnable bias of the module of shape (out_channels)</span>

<span class="sd">    Examples::</span>

<span class="sd">        &gt;&gt;&gt; # With square kernels and equal stride</span>
<span class="sd">        &gt;&gt;&gt; m = nn.Conv3d(16, 33, 3, stride=2)</span>
<span class="sd">        &gt;&gt;&gt; # non-square kernels and unequal stride and with padding</span>
<span class="sd">        &gt;&gt;&gt; m = nn.Conv3d(16, 33, (3, 5, 2), stride=(2, 1, 1), padding=(4, 2, 0))</span>
<span class="sd">        &gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16, 10, 50, 100))</span>
<span class="sd">        &gt;&gt;&gt; output = m(input)</span>

<span class="sd">    .. _cross-correlation:</span>
<span class="sd">        https://en.wikipedia.org/wiki/Cross-correlation</span>

<span class="sd">    .. _link:</span>
<span class="sd">        https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">kernel_size</span> <span class="o">=</span> <span class="n">_triple</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">)</span>
        <span class="n">stride</span> <span class="o">=</span> <span class="n">_triple</span><span class="p">(</span><span class="n">stride</span><span class="p">)</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="n">_triple</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
        <span class="n">dilation</span> <span class="o">=</span> <span class="n">_triple</span><span class="p">(</span><span class="n">dilation</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Conv3d</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span> <span class="n">_triple</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">groups</span><span class="p">,</span> <span class="n">bias</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">conv3d</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dilation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_ConvTransposeMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">output_padding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_padding</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output_size</span><span class="p">)</span>
        <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">ConvNd</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stride</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dilation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transposed</span><span class="p">,</span>
            <span class="n">output_padding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_output_padding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output_size</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">output_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_padding</span>

        <span class="n">output_size</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">output_size</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_size</span><span class="p">)</span> <span class="o">==</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">output_size</span> <span class="o">=</span> <span class="n">output_size</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_size</span><span class="p">)</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;output_size must have </span><span class="si">{}</span><span class="s2"> or </span><span class="si">{}</span><span class="s2"> elements (got </span><span class="si">{}</span><span class="s2">)&quot;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_size</span><span class="p">)))</span>

        <span class="k">def</span> <span class="nf">dim_size</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">((</span><span class="nb">input</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span>
                    <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_size</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>

        <span class="n">min_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim_size</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
        <span class="n">max_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">min_sizes</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">size</span><span class="p">,</span> <span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">output_size</span><span class="p">,</span> <span class="n">min_sizes</span><span class="p">,</span> <span class="n">max_sizes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="n">min_size</span> <span class="ow">or</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">max_size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span>
                    <span class="s2">&quot;requested an output size of </span><span class="si">{}</span><span class="s2">, but valid sizes range &quot;</span>
                    <span class="s2">&quot;from </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2"> (for an input of </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">output_size</span><span class="p">,</span> <span class="n">min_sizes</span><span class="p">,</span> <span class="n">max_sizes</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">size</span><span class="p">()[</span><span class="mi">2</span><span class="p">:]))</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">output_size</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_sizes</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)])</span>


<span class="k">class</span> <span class="nc">ConvTranspose1d</span><span class="p">(</span><span class="n">_ConvTransposeMixin</span><span class="p">,</span> <span class="n">_ConvNd</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Applies a 1D transposed convolution operator over an input image</span>
<span class="sd">    composed of several input planes.</span>

<span class="sd">    This module can be seen as the gradient of Conv1d with respect to its input.</span>
<span class="sd">    It is also known as a fractionally-strided convolution or</span>
<span class="sd">    a deconvolution (although it is not an actual deconvolution operation).</span>

<span class="sd">    | :attr:`stride` controls the stride for the cross-correlation.</span>
<span class="sd">    | If :attr:`padding` is non-zero, then the input is implicitly zero-padded on both sides</span>
<span class="sd">      for :attr:`padding` number of points.</span>
<span class="sd">    | If :attr:`output_padding` is non-zero, then the output is implicitly zero-padded on one side</span>
<span class="sd">      for :attr:`output_padding` number of points.</span>
<span class="sd">    | :attr:`dilation` controls the spacing between the kernel points; also known as the à trous algorithm.</span>
<span class="sd">      It is harder to describe, but this `link`_ has a nice visualization of what :attr:`dilation` does.</span>
<span class="sd">    | :attr:`groups` controls the connections between inputs and outputs. `in_channels` and `out_channels`</span>
<span class="sd">      must both be divisible by `groups`.</span>
<span class="sd">    |       At groups=1, all inputs are convolved to all outputs.</span>
<span class="sd">    |       At groups=2, the operation becomes equivalent to having two conv layers</span>
<span class="sd">                 side by side, each seeing half the input channels,</span>
<span class="sd">                 and producing half the output channels, and both subsequently concatenated.</span>
<span class="sd">            At groups=`in_channels`, each input channel is convolved with its own set of filters</span>
<span class="sd">                 (of size `out_channels // in_channels`).</span>

<span class="sd">    .. note::</span>

<span class="sd">         Depending of the size of your kernel, several (of the last)</span>
<span class="sd">         columns of the input might be lost, because it is a valid `cross-correlation`_,</span>
<span class="sd">         and not a full `cross-correlation`_.</span>
<span class="sd">         It is up to the user to add proper padding.</span>

<span class="sd">    Args:</span>
<span class="sd">        in_channels (int): Number of channels in the input image</span>
<span class="sd">        out_channels (int): Number of channels produced by the convolution</span>
<span class="sd">        kernel_size (int or tuple): Size of the convolving kernel</span>
<span class="sd">        stride (int or tuple, optional): Stride of the convolution</span>
<span class="sd">        padding (int or tuple, optional): Zero-padding added to both sides of the input</span>
<span class="sd">        output_padding (int or tuple, optional): Zero-padding added to one side of the output</span>
<span class="sd">        groups (int, optional): Number of blocked connections from input channels to output channels</span>
<span class="sd">        bias (bool, optional): If True, adds a learnable bias to the output</span>
<span class="sd">        dilation (int or tuple, optional): Spacing between kernel elements</span>

<span class="sd">    Shape:</span>
<span class="sd">        - Input: :math:`(N, C_{in}, L_{in})`</span>
<span class="sd">        - Output: :math:`(N, C_{out}, L_{out})` where</span>
<span class="sd">          :math:`L_{out} = (L_{in} - 1) * stride - 2 * padding + kernel\_size + output\_padding`</span>

<span class="sd">    Attributes:</span>
<span class="sd">        weight (Tensor): the learnable weights of the module of shape</span>
<span class="sd">                         (in_channels, out_channels, kernel_size[0], kernel_size[1])</span>
<span class="sd">        bias (Tensor):   the learnable bias of the module of shape (out_channels)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">output_padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">kernel_size</span> <span class="o">=</span> <span class="n">_single</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">)</span>
        <span class="n">stride</span> <span class="o">=</span> <span class="n">_single</span><span class="p">(</span><span class="n">stride</span><span class="p">)</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="n">_single</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
        <span class="n">dilation</span> <span class="o">=</span> <span class="n">_single</span><span class="p">(</span><span class="n">dilation</span><span class="p">)</span>
        <span class="n">output_padding</span> <span class="o">=</span> <span class="n">_single</span><span class="p">(</span><span class="n">output_padding</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ConvTranspose1d</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">bias</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">output_padding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_padding</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">conv_transpose1d</span><span class="p">(</span>
            <span class="nb">input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">,</span>
            <span class="n">output_padding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dilation</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ConvTranspose2d</span><span class="p">(</span><span class="n">_ConvTransposeMixin</span><span class="p">,</span> <span class="n">_ConvNd</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Applies a 2D transposed convolution operator over an input image</span>
<span class="sd">    composed of several input planes.</span>

<span class="sd">    This module can be seen as the gradient of Conv2d with respect to its input.</span>
<span class="sd">    It is also known as a fractionally-strided convolution or</span>
<span class="sd">    a deconvolution (although it is not an actual deconvolution operation).</span>

<span class="sd">    | :attr:`stride` controls the stride for the cross-correlation.</span>
<span class="sd">    | If :attr:`padding` is non-zero, then the input is implicitly zero-padded on both sides</span>
<span class="sd">      for :attr:`padding` number of points.</span>
<span class="sd">    | If :attr:`output_padding` is non-zero, then the output is implicitly zero-padded on one side</span>
<span class="sd">      for :attr:`output_padding` number of points.</span>
<span class="sd">    | :attr:`dilation` controls the spacing between the kernel points; also known as the à trous algorithm.</span>
<span class="sd">      It is harder to describe, but this `link`_ has a nice visualization of what :attr:`dilation` does.</span>
<span class="sd">    | :attr:`groups` controls the connections between inputs and outputs. `in_channels` and `out_channels`</span>
<span class="sd">      must both be divisible by `groups`.</span>
<span class="sd">    |       At groups=1, all inputs are convolved to all outputs.</span>
<span class="sd">    |       At groups=2, the operation becomes equivalent to having two conv layers</span>
<span class="sd">                 side by side, each seeing half the input channels,</span>
<span class="sd">                 and producing half the output channels, and both subsequently concatenated.</span>
<span class="sd">            At groups=`in_channels`, each input channel is convolved with its own set of filters</span>
<span class="sd">                 (of size `out_channels // in_channels`).</span>

<span class="sd">    The parameters :attr:`kernel_size`, :attr:`stride`, :attr:`padding`, :attr:`output_padding`</span>
<span class="sd">    can either be:</span>

<span class="sd">        - a single ``int`` -- in which case the same value is used for the height and width dimensions</span>
<span class="sd">        - a ``tuple`` of two ints -- in which case, the first `int` is used for the height dimension,</span>
<span class="sd">          and the second `int` for the width dimension</span>

<span class="sd">    .. note::</span>

<span class="sd">         Depending of the size of your kernel, several (of the last)</span>
<span class="sd">         columns of the input might be lost, because it is a valid `cross-correlation`_,</span>
<span class="sd">         and not a full `cross-correlation`_.</span>
<span class="sd">         It is up to the user to add proper padding.</span>

<span class="sd">    Args:</span>
<span class="sd">        in_channels (int): Number of channels in the input image</span>
<span class="sd">        out_channels (int): Number of channels produced by the convolution</span>
<span class="sd">        kernel_size (int or tuple): Size of the convolving kernel</span>
<span class="sd">        stride (int or tuple, optional): Stride of the convolution</span>
<span class="sd">        padding (int or tuple, optional): Zero-padding added to both sides of the input</span>
<span class="sd">        output_padding (int or tuple, optional): Zero-padding added to one side of the output</span>
<span class="sd">        groups (int, optional): Number of blocked connections from input channels to output channels</span>
<span class="sd">        bias (bool, optional): If True, adds a learnable bias to the output</span>
<span class="sd">        dilation (int or tuple, optional): Spacing between kernel elements</span>

<span class="sd">    Shape:</span>
<span class="sd">        - Input: :math:`(N, C_{in}, H_{in}, W_{in})`</span>
<span class="sd">        - Output: :math:`(N, C_{out}, H_{out}, W_{out})` where</span>
<span class="sd">          :math:`H_{out} = (H_{in} - 1) * stride[0] - 2 * padding[0] + kernel\_size[0] + output\_padding[0]`</span>
<span class="sd">          :math:`W_{out} = (W_{in} - 1) * stride[1] - 2 * padding[1] + kernel\_size[1] + output\_padding[1]`</span>

<span class="sd">    Attributes:</span>
<span class="sd">        weight (Tensor): the learnable weights of the module of shape</span>
<span class="sd">                         (in_channels, out_channels, kernel_size[0], kernel_size[1])</span>
<span class="sd">        bias (Tensor):   the learnable bias of the module of shape (out_channels)</span>

<span class="sd">    Examples::</span>

<span class="sd">        &gt;&gt;&gt; # With square kernels and equal stride</span>
<span class="sd">        &gt;&gt;&gt; m = nn.ConvTranspose2d(16, 33, 3, stride=2)</span>
<span class="sd">        &gt;&gt;&gt; # non-square kernels and unequal stride and with padding</span>
<span class="sd">        &gt;&gt;&gt; m = nn.ConvTranspose2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2))</span>
<span class="sd">        &gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16, 50, 100))</span>
<span class="sd">        &gt;&gt;&gt; output = m(input)</span>
<span class="sd">        &gt;&gt;&gt; # exact output size can be also specified as an argument</span>
<span class="sd">        &gt;&gt;&gt; input = autograd.Variable(torch.randn(1, 16, 12, 12))</span>
<span class="sd">        &gt;&gt;&gt; downsample = nn.Conv2d(16, 16, 3, stride=2, padding=1)</span>
<span class="sd">        &gt;&gt;&gt; upsample = nn.ConvTranspose2d(16, 16, 3, stride=2, padding=1)</span>
<span class="sd">        &gt;&gt;&gt; h = downsample(input)</span>
<span class="sd">        &gt;&gt;&gt; h.size()</span>
<span class="sd">        torch.Size([1, 16, 6, 6])</span>
<span class="sd">        &gt;&gt;&gt; output = upsample(h, output_size=input.size())</span>
<span class="sd">        &gt;&gt;&gt; output.size()</span>
<span class="sd">        torch.Size([1, 16, 12, 12])</span>

<span class="sd">    .. _cross-correlation:</span>
<span class="sd">        https://en.wikipedia.org/wiki/Cross-correlation</span>

<span class="sd">    .. _link:</span>
<span class="sd">        https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">output_padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">kernel_size</span> <span class="o">=</span> <span class="n">_pair</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">)</span>
        <span class="n">stride</span> <span class="o">=</span> <span class="n">_pair</span><span class="p">(</span><span class="n">stride</span><span class="p">)</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="n">_pair</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
        <span class="n">dilation</span> <span class="o">=</span> <span class="n">_pair</span><span class="p">(</span><span class="n">dilation</span><span class="p">)</span>
        <span class="n">output_padding</span> <span class="o">=</span> <span class="n">_pair</span><span class="p">(</span><span class="n">output_padding</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ConvTranspose2d</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">bias</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">output_padding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_padding</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">conv_transpose2d</span><span class="p">(</span>
            <span class="nb">input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">,</span>
            <span class="n">output_padding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dilation</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ConvTranspose3d</span><span class="p">(</span><span class="n">_ConvTransposeMixin</span><span class="p">,</span> <span class="n">_ConvNd</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Applies a 3D transposed convolution operator over an input image composed of several input</span>
<span class="sd">    planes.</span>
<span class="sd">    The transposed convolution operator multiplies each input value element-wise by a learnable kernel,</span>
<span class="sd">    and sums over the outputs from all input feature planes.</span>

<span class="sd">    This module can be seen as the gradient of Conv3d with respect to its input.</span>
<span class="sd">    It is also known as a fractionally-strided convolution or</span>
<span class="sd">    a deconvolution (although it is not an actual deconvolution operation).</span>

<span class="sd">    | :attr:`stride` controls the stride for the cross-correlation.</span>
<span class="sd">    | If :attr:`padding` is non-zero, then the input is implicitly zero-padded on both sides</span>
<span class="sd">      for :attr:`padding` number of points.</span>
<span class="sd">    | If :attr:`output_padding` is non-zero, then the output is implicitly zero-padded on one side</span>
<span class="sd">      for :attr:`output_padding` number of points.</span>
<span class="sd">    | :attr:`dilation` controls the spacing between the kernel points; also known as the à trous algorithm.</span>
<span class="sd">      It is harder to describe, but this `link`_ has a nice visualization of what :attr:`dilation` does.</span>
<span class="sd">    | :attr:`groups` controls the connections between inputs and outputs. `in_channels` and `out_channels`</span>
<span class="sd">      must both be divisible by `groups`.</span>
<span class="sd">    |       At groups=1, all inputs are convolved to all outputs.</span>
<span class="sd">    |       At groups=2, the operation becomes equivalent to having two conv layers</span>
<span class="sd">                 side by side, each seeing half the input channels,</span>
<span class="sd">                 and producing half the output channels, and both subsequently concatenated.</span>
<span class="sd">            At groups=`in_channels`, each input channel is convolved with its own set of filters</span>
<span class="sd">                 (of size `out_channels // in_channels`).</span>

<span class="sd">    The parameters :attr:`kernel_size`, :attr:`stride`, :attr:`padding`, :attr:`output_padding`</span>
<span class="sd">    can either be:</span>

<span class="sd">        - a single ``int`` -- in which case the same value is used for the depth, height and width dimensions</span>
<span class="sd">        - a ``tuple`` of three ints -- in which case, the first `int` is used for the depth dimension,</span>
<span class="sd">          the second `int` for the height dimension and the third `int` for the width dimension</span>

<span class="sd">    .. note::</span>

<span class="sd">         Depending of the size of your kernel, several (of the last)</span>
<span class="sd">         columns of the input might be lost, because it is a valid `cross-correlation`_,</span>
<span class="sd">         and not a full `cross-correlation`_.</span>
<span class="sd">         It is up to the user to add proper padding.</span>

<span class="sd">    Args:</span>
<span class="sd">        in_channels (int): Number of channels in the input image</span>
<span class="sd">        out_channels (int): Number of channels produced by the convolution</span>
<span class="sd">        kernel_size (int or tuple): Size of the convolving kernel</span>
<span class="sd">        stride (int or tuple, optional): Stride of the convolution</span>
<span class="sd">        padding (int or tuple, optional): Zero-padding added to both sides of the input</span>
<span class="sd">        output_padding (int or tuple, optional): Zero-padding added to one side of the output</span>
<span class="sd">        groups (int, optional): Number of blocked connections from input channels to output channels</span>
<span class="sd">        bias (bool, optional): If True, adds a learnable bias to the output</span>
<span class="sd">        dilation (int or tuple, optional): Spacing between kernel elements</span>

<span class="sd">    Shape:</span>
<span class="sd">        - Input: :math:`(N, C_{in}, D_{in}, H_{in}, W_{in})`</span>
<span class="sd">        - Output: :math:`(N, C_{out}, D_{out}, H_{out}, W_{out})` where</span>
<span class="sd">          :math:`D_{out} = (D_{in} - 1) * stride[0] - 2 * padding[0] + kernel\_size[0] + output\_padding[0]`</span>
<span class="sd">          :math:`H_{out} = (H_{in} - 1) * stride[1] - 2 * padding[1] + kernel\_size[1] + output\_padding[1]`</span>
<span class="sd">          :math:`W_{out} = (W_{in} - 1) * stride[2] - 2 * padding[2] + kernel\_size[2] + output\_padding[2]`</span>

<span class="sd">    Attributes:</span>
<span class="sd">        weight (Tensor): the learnable weights of the module of shape</span>
<span class="sd">                         (in_channels, out_channels, kernel_size[0], kernel_size[1], kernel_size[2])</span>
<span class="sd">        bias (Tensor):   the learnable bias of the module of shape (out_channels)</span>

<span class="sd">    Examples::</span>

<span class="sd">        &gt;&gt;&gt; # With square kernels and equal stride</span>
<span class="sd">        &gt;&gt;&gt; m = nn.ConvTranspose3d(16, 33, 3, stride=2)</span>
<span class="sd">        &gt;&gt;&gt; # non-square kernels and unequal stride and with padding</span>
<span class="sd">        &gt;&gt;&gt; m = nn.Conv3d(16, 33, (3, 5, 2), stride=(2, 1, 1), padding=(0, 4, 2))</span>
<span class="sd">        &gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16, 10, 50, 100))</span>
<span class="sd">        &gt;&gt;&gt; output = m(input)</span>

<span class="sd">    .. _cross-correlation:</span>
<span class="sd">        https://en.wikipedia.org/wiki/Cross-correlation</span>

<span class="sd">    .. _link:</span>
<span class="sd">        https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">output_padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">kernel_size</span> <span class="o">=</span> <span class="n">_triple</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">)</span>
        <span class="n">stride</span> <span class="o">=</span> <span class="n">_triple</span><span class="p">(</span><span class="n">stride</span><span class="p">)</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="n">_triple</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
        <span class="n">dilation</span> <span class="o">=</span> <span class="n">_triple</span><span class="p">(</span><span class="n">dilation</span><span class="p">)</span>
        <span class="n">output_padding</span> <span class="o">=</span> <span class="n">_triple</span><span class="p">(</span><span class="n">output_padding</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ConvTranspose3d</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">bias</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">output_padding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_padding</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">conv_transpose3d</span><span class="p">(</span>
            <span class="nb">input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">,</span>
            <span class="n">output_padding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dilation</span><span class="p">)</span>


<span class="c1"># TODO: Conv2dLocal</span>
<span class="c1"># TODO: Conv2dMap</span>
<span class="c1"># TODO: ConvTranspose2dMap</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Author.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>